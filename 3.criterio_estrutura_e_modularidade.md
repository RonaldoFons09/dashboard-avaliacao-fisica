# Critério 3 — Estrutura e Modularidade

## Definição

O código deve ser organizado em **unidades pequenas, coesas e bem delimitadas**, de forma que cada parte tenha uma responsabilidade clara e um contexto bem definido.

Boa estrutura e modularidade tornam o sistema **mais fácil de entender, evoluir, testar e manter**.

---

## Princípio central

Software bem estruturado é composto por **peças pequenas que se conectam**, não por blocos grandes que fazem tudo ao mesmo tempo.

A modularidade permite:
- separar responsabilidades
- reduzir acoplamento
- isolar mudanças
- facilitar reaproveitamento

---

## 1️⃣ Métodos e Funções Curtos

### O que este ponto exige

Funções e métodos devem:
- ser **curtos**
- executar **uma única tarefa**
- não misturar responsabilidades diferentes

Uma função deve representar **uma ação clara**, descrita por seu nome.

---

### Regra prática

> Se você precisa usar “e” para descrever o que a função faz, ela faz coisas demais.

---

### Exemplo

❌ Função com múltiplas responsabilidades

```python
def processar_pedido(pedido):
    validar_pedido(pedido)
    salvar_no_banco(pedido)
    enviar_email_confirmacao(pedido)
```

Problemas:
- mistura validação, persistência e comunicação
- difícil de testar isoladamente

---

✅ Funções curtas e bem definidas

```python
def validar_pedido(pedido):
    ...

def salvar_pedido(pedido):
    ...

def enviar_confirmacao(pedido):
    ...
```

---

## 2️⃣ Contexto Bem Definido

### O que este ponto exige

Cada módulo, classe ou função deve atuar em **um único contexto**.

O código **não deve atravessar fronteiras desnecessárias**, como:
- lógica de negócio acessando detalhes de banco
- regras de domínio lidando com interface ou infraestrutura

---

### Boa prática

Quando um código precisa conversar com outro contexto, use:
- classes adaptadoras
- camadas intermediárias
- estruturas auxiliares

Esses elementos protegem o núcleo do sistema de dependências externas.

---

### Exemplo

❌ Contextos misturados

```python
def calcular_total(pedido):
    conexao = conectar_banco()
    salvar_total(conexao, pedido)
    return pedido.total
```

---

✅ Contextos separados

```python
def calcular_total(pedido):
    return pedido.total

class PedidoRepository:
    def salvar(self, pedido):
        ...
```

---

## 3️⃣ Uso de Padrões de Projeto (Design Patterns)

### O que são

Padrões de projeto são **soluções consolidadas** para problemas recorrentes de estrutura e organização de software.

Eles atuam como um **vocabulário comum**, facilitando:
- comunicação entre desenvolvedores
- alinhamento de decisões técnicas
- entendimento da arquitetura

---

### Como usar corretamente

- Utilize padrões **quando o problema justificar**, não por moda
- Prefira simplicidade antes de introduzir abstrações
- Use padrões para **clarificar a intenção**, não para complicar

---

### Exemplos comuns

- **Factory**: criação controlada de objetos
- **Adapter**: integração entre interfaces incompatíveis
- **Strategy**: variação de comportamento
- **Repository**: isolamento da camada de dados

---

## Checklist de avaliação

Use as perguntas abaixo para validar este critério:

- [ ] As funções são curtas e fazem apenas uma coisa?
- [ ] As responsabilidades estão bem separadas?
- [ ] Os contextos não estão misturados?
- [ ] Mudanças em uma parte afetam o mínimo possível do sistema?
- [ ] Padrões de projeto estão sendo usados para clareza, não complexidade?

Se alguma resposta for **não**, a estrutura e modularidade devem ser revisadas.

---

## Frase-guia

> **Código bem estruturado é aquele em que cada parte sabe exatamente qual é o seu papel — e nada além disso.**

---

## Objetivo do critério

Garantir que o sistema seja:

- organizado
- flexível
- testável
- fácil de evoluir

Boa estrutura não surge por acaso: ela é resultado de decisões conscientes de modularização.

